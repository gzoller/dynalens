

    val unique = items[].id.distinct()
    maybe.skills[].name = maybe.skills.len() :: "wow"  <- For Option[List[?]], None == Nil
    val x = maybe.desc  <-- may be None (desc is Option[String])
    maybe.desc = x -> _ :: "wow"  // like x.map(_+"wow")

    foo.things[].filter(this.startsWith("x"))


TODO:

* Make sure working code in Grammar is also propagated into BlockFn and BlockStmt -- test both


    Possible additions:

    * Options and Collections as first-class values
    * Simple map -> for Option
    * Tracking course types: simple, Option, Collection, Map:
        maybe use foo, foo[], foo{}, foo? foo[]?, foo{}? to denote the type
    * Support Map mutation
    * More detailed error messages w/line,pos


    I think that’s a good default for a lens‑focused language:

    Within collection predicates (and other per‑item transforms), if the projected field is Option[T], treat None as “absent” and simply skip it.
    i.e., work over items.flatMap(_.blah) rather than items.map(_.blah).

    Why this makes sense here
    	•	Lens semantics > GP language: You’re shaping data, not proving total functions. Skipping missing leaves is usually what users intend.
    	•	Predictable filtering: filter(_.blah?) should keep elements where blah is present and satisfies the predicate; elements with blah = None are naturally dropped from consideration for that predicate.
    	•	Reduces boilerplate: Avoids forcing x.isDefined checks or .else(...) inside every predicate.

    Where to apply the rule
    	•	In collection predicates and mappers that iterate items (e.g., filter, map, distinct, sortAsc(field)):
    	•	When dereferencing a path ending in ? (optional) within the item scope, ignore None:
    	•	filter(this.blah? > 10) → keep items with blah = Some(v) and v > 10; items with None neither pass nor fail (they’re dropped).
    	•	map(this.blah?) → produce only the Some values (effectively flatMap).
    	•	In scalar contexts (outside an iterable), keep current behavior:
    	•	val x = foo.blah? → Option[...] value, not silently dropped.
    	•	You still need .else(...) when you want a default.

    Edge cases & clarity
    	•	Sorting with optional keys: Two good defaults:
    	1.	Stable skip: exclude items where the sort key is None.
    	2.	Group last: treat None as larger than all Some for total ordering.
    Pick one and document it (I’d choose group last for stability and to avoid surprising count drops).
    	•	Distinct on optional field: Define on the present values only; decide whether items with None collapse to a single bucket or are excluded. I’d exclude them to avoid ambiguous grouping.
    	•	Length / stats after skipping: Be explicit: methods like .len() on a mapped optional field inside a collection operate on the post‑skip stream. Document: “None values are not counted.”

    Give users an explicit escape hatch

    Even if skip is the default, offer knobs so advanced users can control it:
    	•	.present (predicate): keep only items where the optional field is defined.
    items[].filter(this.blah?.present) → explicit, self‑documenting.
    	•	.flattenOption() (function on collections): turns List[Option[T]] into List[T].
    This might happen implicitly in map; exposing it allows standalone use.
    	•	.keepNone() (flag/variant) on ops like sort/distinct: include None with defined ordering/bucket.
    	•	e.g., items[].sortAsc(this.blah?).keepNoneFirst() / .keepNoneLast().
    	•	.default(v) (alias of .else(v) in per‑item scope) when you don’t want skipping:
    	•	items[].map(this.blah?.default(0)) → totalize before mapping.

    Implementation sketch
    	•	In per‑item evaluation (the iterator lens):
    	•	When you see a terminal path with ?, have the accessor return Iterator.empty for None and Iterator(v) for Some(v).
    That makes the surrounding op naturally flatMap over options.
    	•	For boolean predicates:
    	•	Evaluate to tri‑state: True, False, Absent. Treat Absent as not matching (i.e., drop item).
    	•	For sort/distinct:
    	•	Accept a KeyResult = Present(T) | Absent. Use chosen policy for Absent.

    Documentation snippet (to set expectations)

    Option‑aware collection ops. Inside collection transforms (e.g., items[]), optional fields (?) are treated as absent values: None is skipped by default. Predicates only consider present values; mappers flatten out None. Use .default(...) to supply a value instead of skipping, or .present to filter to only present entries. For sorting/distinct, absent keys are grouped last (default).

    This keeps the language ergonomic for its core purpose, while still giving control when users need stricter behavior.


final case class SortFn(recv: Fn[Any], keyPath: Option[String], ascending: Boolean)
  extends Fn[Any] {

  private def keyFn: Option[Fn[Any]] =
    keyPath.map(p => GetFn(p, searchThis = true).asInstanceOf[Fn[Any]])

  def resolve(ctx: DynaContext): ZIO[_BiMapRegistry, DynaLensError, Any] =
    for {
      raw   <- recv.resolve(ctx)
      seq   <- ZIO.fromEither(asSeq(raw, "sort"))
      out   <- keyFn match {
                 case None =>
                   // natural ordering of the elements themselves
                   ZIO.attempt {
                     val withAny = seq.asInstanceOf[Seq[Any]]
                     val sorted = withAny.sortBy(_.asInstanceOf[Comparable[Any]]) // will throw if not comparable
                     if (ascending) sorted else sorted.reverse
                   }.mapError(t => DynaLensError(s"sort requires Comparable elements: ${t.getMessage}"))

                 case Some(kf) =>
                   // key-based ordering
                   ZIO.foreach(seq){ e =>
                     kf.resolve(withElemCtx(e, ctx)).map(k => (e, k))
                   }.flatMap { pairs =>
                     ZIO.attempt {
                       val sorted = pairs.sortBy(_._2.asInstanceOf[Comparable[Any]])
                       (if (ascending) sorted else sorted.reverse).map(_._1)
                     }.mapError(t => DynaLensError(s"sort key must be Comparable: ${t.getMessage}"))
                   }
               }
    } yield out
}


final case class DistinctFn(recv: Fn[Any], keyPath: Option[String]) extends Fn[Any] {
  private def keyFn: Option[Fn[Any]] =
    keyPath.map(p => GetFn(p, searchThis = true).asInstanceOf[Fn[Any]])

  def resolve(ctx: DynaContext): ZIO[_BiMapRegistry, DynaLensError, Any] =
    for {
      raw <- recv.resolve(ctx)
      seq <- ZIO.fromEither(asSeq(raw, "distinct"))
      out <- keyFn match {
               case None =>
                 ZIO.succeed(seq.distinct) // uses equals/hashCode of elements
               case Some(kf) =>
                 ZIO.foreach(seq){ e =>
                   kf.resolve(withElemCtx(e, ctx)).map(k => (k, e))
                 }.map { pairs =>
                   pairs
                     .foldLeft((Set.empty[Any], Vector.empty[Any])) {
                       case ((seen, acc), (k, e)) =>
                         if (seen(k)) (seen, acc) else (seen + k, acc :+ e)
                     }._2
                 }
             }
    } yield out
}

final case class ReverseFn(recv: Fn[Any]) extends Fn[Any] {
  def resolve(ctx: DynaContext): ZIO[_BiMapRegistry, DynaLensError, Any] =
    for {
      raw <- recv.resolve(ctx)
      seq <- ZIO.fromEither(asSeq(raw, "reverse"))
    } yield seq.reverse
}

    final case class CleanFn(recv: Fn[Any]) extends Fn[Any] {
      def resolve(ctx: DynaContext): ZIO[_BiMapRegistry, DynaLensError, Any] =
        for {
          raw <- recv.resolve(ctx)
          seq <- ZIO.fromEither(asSeq(raw, "clean"))
        } yield seq.collect {
          case s: String if s != null && s.nonEmpty => s
          case x if x != null && !x.isInstanceOf[String] => x
        }
    }


    //-----
	2.	At runtime (value of this per iteration)
On each iteration, you must also update the value of this in the runtime context (DynaContext) so GetFn("this") (or bare fields that rewrite to this.foo) can read the current element’s value.
A tiny helper makes this clean:

    // DynaLens.scala (inside your class)
    private def withThis[A](
      outerCtx: DynaContext,
      value: Any,
      elemLens: Option[DynaLens[_]]
    )(run: DynaContext => ZIO[_BiMapRegistry, DynaLensError, A])
    : ZIO[_BiMapRegistry, DynaLensError, A] =
      // store exactly like the rest of your code expects: ("name" -> (value, maybeLens))
      run(outerCtx.clone.addOne("this", (value, elemLens)))