package co.blocke.dynalens
package parser

import fastparse.*, NoWhitespace.*

//
// Second level:
//   arithmetic support
//   blocks (statement and fn)
//   if support
//
trait Level2 extends Level1:

  def booleanAtom[$: P]: P[BooleanFn] =
    P(
      "(" ~/ booleanExpr ~ ")" |
        comparisonExpr | // e.g., x == 10
        booleanLiteral |
        arithmeticExpr.map(toBooleanFn) // includes bare paths like `x` or `foo.bar`
    )


/*


  // Precedence: factor (highest), term (medium), expr (lowest)
//  private def factor[$: P](expr: => P[Fn[Any]]): P[Fn[Any]] =
//    P(parens(expr) | baseExpr(expr))
//
//  private def parens[$: P](expr: => P[Fn[Any]]): P[Fn[Any]] =
//    P("(" ~/ expr ~ ")" ~ WS0)
//
//  private def term[$: P](expr: => P[Fn[Any]]): P[Fn[Any]] =
//    P(factor(expr) ~ (CharIn("*/").! ~ WS0 ~ factor(expr)).rep).map {
//      case (left, rest) =>
//        rest.foldLeft(left) {
//          case (acc, ("*", right)) => MultiplyFn(acc, right)
//          case (acc, ("/", right)) => DivideFn(acc, right)
//        }
//    }
//
//  def arithmeticExpr[$: P](expr: => P[Fn[Any]]): P[Fn[Any]] =
//    P(term(expr) ~ (CharIn("+\\-").! ~ WS0 ~ term(expr)).rep).map {
//      case (left, rest) =>
//        rest.foldLeft(left) {
//          case (acc, ("+", right)) => AddFn(acc, right)
//          case (acc, ("-", right)) => SubtractFn(acc, right)
//        }
//    }

  private def factor[$: P](expr: => P[Fn[Any]]): P[Fn[Any]] =
    P(baseExpr(expr) | ("(" ~ expr ~ ")")) // removed `~/`

  private def term[$: P](expr: => P[Fn[Any]]): P[Fn[Any]] =
    P(factor(expr) ~ (CharIn("*/").! ~ WS0 ~ factor(expr)).rep).map {
      case (left, rest) =>
        rest.foldLeft(left) {
          case (acc, ("*", right)) => MultiplyFn(acc, right)
          case (acc, ("/", right)) => DivideFn(acc, right)
        }
    }

  def arithmeticExpr[$: P](expr: => P[Fn[Any]]): P[Fn[Any]] =
    P(term(expr) ~ (CharIn("+\\-").! ~ WS0 ~ term(expr)).rep).map {
      case (left, rest) =>
        rest.foldLeft(left) {
          case (acc, ("+", right)) => AddFn(acc, right)
          case (acc, ("-", right)) => SubtractFn(acc, right)
        }
    }

  // ---- blocks ----

  def blockFn[$: P](expr: => P[Fn[Any]]): P[Fn[Any]] =
    P("{" ~/ WS0 ~ statement.rep ~ expr ~ "}").map {
        case (stmts, finalFn) =>
          BlockFn(stmts, finalFn)
      }

  private def blockStmt[$: P](expr: => P[Fn[Any]]): P[Statement] =
    P("{" ~/ statement.rep ~ "}").map(BlockStmt(_))

  // ---- statements ----

  private def valDecl[$: P](expr: => P[Fn[Any]]): P[ValStmt[?]] =
    P("val" ~/ WS ~ identifier.! ~ WS0 ~ "=" ~ WS0 ~ expr).map {
      case (name, valueExpr) =>
        ValStmt(name, valueExpr)
    }

  private def updateOrMapStmt[$: P](expr: => P[Fn[Any]]): P[Statement] =
    P(path.log("UPDATE PATH").map{s=>println("Update captured: "+s);s} ~ WS0 ~ "=" ~/ WS0 ~ expr).map { case (p, v) =>
      if p.contains("[]") then MapStmt(p, v) else UpdateStmt(p, v)
    }

  def statement[$: P]: P[Statement] =
    P(WS0 ~ (ifStmt(fullExpr).log("IF>>>") | updateOrMapStmt(fullExpr).log("UP>>>") | valDecl(fullExpr).log("VAL>>>") | blockStmt(fullExpr).log("BLOCK>>>")) ~ WS0)

  // This is the entry point to expression parsing
  def fullExpr[$: P]: P[Fn[Any]] = valueExpr(fullExpr)

  def attemptComparison[$: P](expr: => P[Fn[Any]]): P[Fn[Any]] =
    comparisonExpr(expr).asInstanceOf[P[Fn[Any]]] // Upcast BooleanFn to Fn[Any]

  def valueExpr[$: P](expr: => P[Fn[Any]]): P[Fn[Any]] =
    attemptComparison(expr) | arithmeticExpr(expr) | constant

  // ---- if ----

  def comparisonExpr[$: P](expr: => P[Fn[Any]]): P[BooleanFn] =
    P(arithmeticExpr(expr) ~ (
      StringIn("==", "!=", ">=", "<=", ">", "<").! ~ arithmeticExpr(expr)
      ).rep).flatMap {
      case (left, Nil) =>
        left match
          case b: BooleanFn => P(Pass(b))
          case _ => P(Fail)
      case (left, ops) =>
        // All comparison operators yield BooleanFns
        val result: BooleanFn = ops.foldLeft(left) {
          case (acc, ("==", right)) => EqualFn(acc, right)
          case (acc, ("!=", right)) => NotEqualFn(acc, right)
          case (acc, (">", right)) => GreaterThanFn(acc, right)
          case (acc, ("<", right)) => LessThanFn(acc, right)
          case (acc, (">=", right)) => GreaterThanOrEqualFn(acc, right)
          case (acc, ("<=", right)) => LessThanOrEqualFn(acc, right)
        }.asInstanceOf[BooleanFn] // Safe if all Fn constructors return BooleanFn
        P(Pass(result))
    }

  private def ensureBoolean(fn: Fn[Any], op: String): BooleanFn = fn match
    case b: BooleanFn => b
    case _ => throw new RuntimeException(s"$op requires boolean expressions")

  private def boolOrExpr[$: P](expr: => P[Fn[Any]]): P[BooleanFn] =
    P(boolAndExpr(expr) ~ ("||" ~/ WS0 ~ boolAndExpr(expr)).rep).map {
      case (left, rest) =>
        val result = rest.foldLeft(ensureBoolean(left, "||")) {
          case (acc, next) => OrFn(acc, ensureBoolean(next, "||"))
        }
        result // now seen as Fn[Any] due to +R
    }

  private def boolAndExpr[$: P](expr: => P[Fn[Any]]): P[BooleanFn] =
    P(boolNotExpr(expr) ~ ("&&" ~/ WS0 ~ boolNotExpr(expr)).rep).map {
      case (left, rest) =>
        rest.foldLeft(ensureBoolean(left, "&&")) { (acc, next) =>
          AndFn(acc, ensureBoolean(next, "&&"))
        }
    }

  private def boolNotExpr[$: P](expr: => P[Fn[Any]]): P[BooleanFn] =
    P("!" ~/ WS0.? ~ boolBaseExpr(expr)).map {
      case b: BooleanFn => NotFn(b)
      case _ => throw new RuntimeException("! operator expects a boolean expression")
    }

  private def boolBaseExpr[$: P](expr: => P[Fn[Any]]): P[BooleanFn] =
    P(
      "(" ~/ booleanExpr(expr) ~ ")" |
        comparisonExpr(expr)
    )
  /*
  private def boolNotExpr[$: P](expr: => P[Fn[Any]]): P[BooleanFn] =
    P("!" ~/ WS0.? ~ boolBaseExpr(expr)).map {
      (fn: Fn[?]) =>
        fn match {
          case b: BooleanFn => NotFn(b)
          case _ => throw new RuntimeException("! operator expects a boolean expression")
        }
    }

  private def boolBaseExpr[$: P](expr: => P[Fn[Any]]): P[BooleanFn] =
    P(
      ("(" ~/ booleanExpr(expr) ~ ")") |
        comparisonExpr(expr)
    )
    */

  def booleanExpr[$: P](expr: => P[Fn[Any]]): P[BooleanFn] =
    boolOrExpr(expr)

  private def statementOrBlock[$: P](expr: => P[Fn[Any]]): P[Statement] =
    P(blockStmt(expr) | statement)

  private def ifStmt[$: P](expr: => P[Fn[Any]]): P[IfStmt] =
    P("if" ~/ WS ~ expr ~ WS0 ~ "then" ~/ WS ~ statementOrBlock(expr) ~ ("else" ~/ WS ~ statementOrBlock(expr)).?).map {
      case (condFn, thenStmt, elseOpt) =>
        condFn match
          case b: BooleanFn => IfStmt(b, thenStmt, elseOpt)
          case other => throw new RuntimeException(s"if condition must be Boolean expression, got: $other")
    }

  def ifFn[$: P](expr: => P[Fn[Any]]): P[Fn[Any]] =
    P("if" ~/ WS ~ expr ~ WS0 ~ "then" ~/ WS ~ blockFn(expr) ~ WS ~ "else" ~/ WS ~ blockFn(expr)).map {
      case (condition, thenBlock, elseBlock) =>
        condition match
          case b: BooleanFn => IfFn(b, thenBlock, elseBlock)
          case other => throw new RuntimeException(s"ifFn condition must be a Boolean expression, got: $other")
    }

*/

    /* TODO:
       How to handle Option[]

    * Do arithmeticExprs for comparisons handle strings?  For example "foo" == "bar"?

    */
